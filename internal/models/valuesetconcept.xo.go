package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// ValueSetConcept represents a row from 'public.value_set_concept'.
type ValueSetConcept struct {
	ID                      string         `json:"id"`                      // id
	Codesystemoid           sql.NullString `json:"codesystemoid"`           // codesystemoid
	Valuesetversionid       sql.NullString `json:"valuesetversionid"`       // valuesetversionid
	Conceptcode             sql.NullString `json:"conceptcode"`             // conceptcode
	Scopenotetext           sql.NullString `json:"scopenotetext"`           // scopenotetext
	Status                  sql.NullString `json:"status"`                  // status
	Cdcpreferreddesignation sql.NullString `json:"cdcpreferreddesignation"` // cdcpreferreddesignation
	Preferredalternatecode  sql.NullString `json:"preferredalternatecode"`  // preferredalternatecode
	Definitiontext          sql.NullString `json:"definitiontext"`          // definitiontext
	Codesystemconceptname   sql.NullString `json:"codesystemconceptname"`   // codesystemconceptname
	Sequence                sql.NullString `json:"sequence"`                // sequence
	Statusdate              sql.NullTime   `json:"statusdate"`              // statusdate
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [ValueSetConcept] exists in the database.
func (vsc *ValueSetConcept) Exists() bool {
	return vsc._exists
}

// Deleted returns true when the [ValueSetConcept] has been marked for deletion
// from the database.
func (vsc *ValueSetConcept) Deleted() bool {
	return vsc._deleted
}

// Insert inserts the [ValueSetConcept] to the database.
func (vsc *ValueSetConcept) Insert(ctx context.Context, db DB) error {
	switch {
	case vsc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case vsc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.value_set_concept (` +
		`id, codesystemoid, valuesetversionid, conceptcode, scopenotetext, status, cdcpreferreddesignation, preferredalternatecode, definitiontext, codesystemconceptname, sequence, statusdate` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`)`
	// run
	logf(sqlstr, vsc.ID, vsc.Codesystemoid, vsc.Valuesetversionid, vsc.Conceptcode, vsc.Scopenotetext, vsc.Status, vsc.Cdcpreferreddesignation, vsc.Preferredalternatecode, vsc.Definitiontext, vsc.Codesystemconceptname, vsc.Sequence, vsc.Statusdate)
	if _, err := db.ExecContext(ctx, sqlstr, vsc.ID, vsc.Codesystemoid, vsc.Valuesetversionid, vsc.Conceptcode, vsc.Scopenotetext, vsc.Status, vsc.Cdcpreferreddesignation, vsc.Preferredalternatecode, vsc.Definitiontext, vsc.Codesystemconceptname, vsc.Sequence, vsc.Statusdate); err != nil {
		return logerror(err)
	}
	// set exists
	vsc._exists = true
	return nil
}

// Update updates a [ValueSetConcept] in the database.
func (vsc *ValueSetConcept) Update(ctx context.Context, db DB) error {
	switch {
	case !vsc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case vsc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.value_set_concept SET ` +
		`codesystemoid = $1, valuesetversionid = $2, conceptcode = $3, scopenotetext = $4, status = $5, cdcpreferreddesignation = $6, preferredalternatecode = $7, definitiontext = $8, codesystemconceptname = $9, sequence = $10, statusdate = $11 ` +
		`WHERE id = $12`
	// run
	logf(sqlstr, vsc.Codesystemoid, vsc.Valuesetversionid, vsc.Conceptcode, vsc.Scopenotetext, vsc.Status, vsc.Cdcpreferreddesignation, vsc.Preferredalternatecode, vsc.Definitiontext, vsc.Codesystemconceptname, vsc.Sequence, vsc.Statusdate, vsc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, vsc.Codesystemoid, vsc.Valuesetversionid, vsc.Conceptcode, vsc.Scopenotetext, vsc.Status, vsc.Cdcpreferreddesignation, vsc.Preferredalternatecode, vsc.Definitiontext, vsc.Codesystemconceptname, vsc.Sequence, vsc.Statusdate, vsc.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [ValueSetConcept] to the database.
func (vsc *ValueSetConcept) Save(ctx context.Context, db DB) error {
	if vsc.Exists() {
		return vsc.Update(ctx, db)
	}
	return vsc.Insert(ctx, db)
}

// Upsert performs an upsert for [ValueSetConcept].
func (vsc *ValueSetConcept) Upsert(ctx context.Context, db DB) error {
	switch {
	case vsc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.value_set_concept (` +
		`id, codesystemoid, valuesetversionid, conceptcode, scopenotetext, status, cdcpreferreddesignation, preferredalternatecode, definitiontext, codesystemconceptname, sequence, statusdate` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`codesystemoid = EXCLUDED.codesystemoid, valuesetversionid = EXCLUDED.valuesetversionid, conceptcode = EXCLUDED.conceptcode, scopenotetext = EXCLUDED.scopenotetext, status = EXCLUDED.status, cdcpreferreddesignation = EXCLUDED.cdcpreferreddesignation, preferredalternatecode = EXCLUDED.preferredalternatecode, definitiontext = EXCLUDED.definitiontext, codesystemconceptname = EXCLUDED.codesystemconceptname, sequence = EXCLUDED.sequence, statusdate = EXCLUDED.statusdate `
	// run
	logf(sqlstr, vsc.ID, vsc.Codesystemoid, vsc.Valuesetversionid, vsc.Conceptcode, vsc.Scopenotetext, vsc.Status, vsc.Cdcpreferreddesignation, vsc.Preferredalternatecode, vsc.Definitiontext, vsc.Codesystemconceptname, vsc.Sequence, vsc.Statusdate)
	if _, err := db.ExecContext(ctx, sqlstr, vsc.ID, vsc.Codesystemoid, vsc.Valuesetversionid, vsc.Conceptcode, vsc.Scopenotetext, vsc.Status, vsc.Cdcpreferreddesignation, vsc.Preferredalternatecode, vsc.Definitiontext, vsc.Codesystemconceptname, vsc.Sequence, vsc.Statusdate); err != nil {
		return logerror(err)
	}
	// set exists
	vsc._exists = true
	return nil
}

// Delete deletes the [ValueSetConcept] from the database.
func (vsc *ValueSetConcept) Delete(ctx context.Context, db DB) error {
	switch {
	case !vsc._exists: // doesn't exist
		return nil
	case vsc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.value_set_concept ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, vsc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, vsc.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	vsc._deleted = true
	return nil
}

// ValueSetConceptByCodesystemoid retrieves a row from 'public.value_set_concept' as a [ValueSetConcept].
//
// Generated from index 'value_set_concept_codesystemoid_idx'.
func ValueSetConceptByCodesystemoid(ctx context.Context, db DB, codesystemoid sql.NullString) ([]*ValueSetConcept, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, codesystemoid, valuesetversionid, conceptcode, scopenotetext, status, cdcpreferreddesignation, preferredalternatecode, definitiontext, codesystemconceptname, sequence, statusdate ` +
		`FROM public.value_set_concept ` +
		`WHERE codesystemoid = $1`
	// run
	logf(sqlstr, codesystemoid)
	rows, err := db.QueryContext(ctx, sqlstr, codesystemoid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*ValueSetConcept
	for rows.Next() {
		vsc := ValueSetConcept{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&vsc.ID, &vsc.Codesystemoid, &vsc.Valuesetversionid, &vsc.Conceptcode, &vsc.Scopenotetext, &vsc.Status, &vsc.Cdcpreferreddesignation, &vsc.Preferredalternatecode, &vsc.Definitiontext, &vsc.Codesystemconceptname, &vsc.Sequence, &vsc.Statusdate); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &vsc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// ValueSetConceptByID retrieves a row from 'public.value_set_concept' as a [ValueSetConcept].
//
// Generated from index 'value_set_concept_distinct_pkey'.
func ValueSetConceptByID(ctx context.Context, db DB, id string) (*ValueSetConcept, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, codesystemoid, valuesetversionid, conceptcode, scopenotetext, status, cdcpreferreddesignation, preferredalternatecode, definitiontext, codesystemconceptname, sequence, statusdate ` +
		`FROM public.value_set_concept ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	vsc := ValueSetConcept{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&vsc.ID, &vsc.Codesystemoid, &vsc.Valuesetversionid, &vsc.Conceptcode, &vsc.Scopenotetext, &vsc.Status, &vsc.Cdcpreferreddesignation, &vsc.Preferredalternatecode, &vsc.Definitiontext, &vsc.Codesystemconceptname, &vsc.Sequence, &vsc.Statusdate); err != nil {
		return nil, logerror(err)
	}
	return &vsc, nil
}

// ValueSetConceptByValuesetversionid retrieves a row from 'public.value_set_concept' as a [ValueSetConcept].
//
// Generated from index 'value_set_concept_valuesetversionid_idx'.
func ValueSetConceptByValuesetversionid(ctx context.Context, db DB, valuesetversionid sql.NullString) ([]*ValueSetConcept, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, codesystemoid, valuesetversionid, conceptcode, scopenotetext, status, cdcpreferreddesignation, preferredalternatecode, definitiontext, codesystemconceptname, sequence, statusdate ` +
		`FROM public.value_set_concept ` +
		`WHERE valuesetversionid = $1`
	// run
	logf(sqlstr, valuesetversionid)
	rows, err := db.QueryContext(ctx, sqlstr, valuesetversionid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*ValueSetConcept
	for rows.Next() {
		vsc := ValueSetConcept{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&vsc.ID, &vsc.Codesystemoid, &vsc.Valuesetversionid, &vsc.Conceptcode, &vsc.Scopenotetext, &vsc.Status, &vsc.Cdcpreferreddesignation, &vsc.Preferredalternatecode, &vsc.Definitiontext, &vsc.Codesystemconceptname, &vsc.Sequence, &vsc.Statusdate); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &vsc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CodeSystem returns the CodeSystem associated with the [ValueSetConcept]'s (Codesystemoid).
//
// Generated from foreign key 'value_set_concept_codesystemoid_fkey'.
func (vsc *ValueSetConcept) CodeSystem(ctx context.Context, db DB) (*CodeSystem, error) {
	return CodeSystemByOid(ctx, db, vsc.Codesystemoid.String)
}

// ValueSetVersion returns the ValueSetVersion associated with the [ValueSetConcept]'s (Valuesetversionid).
//
// Generated from foreign key 'value_set_concept_valuesetversionid_fkey'.
func (vsc *ValueSetConcept) ValueSetVersion(ctx context.Context, db DB) (*ValueSetVersion, error) {
	return ValueSetVersionByID(ctx, db, vsc.Valuesetversionid.String)
}
