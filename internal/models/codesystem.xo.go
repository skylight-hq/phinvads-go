// Package models contains generated code for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// CodeSystem represents a row from 'public.code_system'.
type CodeSystem struct {
	Oid                           string         `json:"oid"`                           // oid
	ID                            string         `json:"id"`                            // id
	Name                          string         `json:"name"`                          // name
	Definitiontext                sql.NullString `json:"definitiontext"`                // definitiontext
	Status                        string         `json:"status"`                        // status
	Version                       string         `json:"version"`                       // version
	Versiondescription            sql.NullString `json:"versiondescription"`            // versiondescription
	Assigningauthorityversionname sql.NullString `json:"assigningauthorityversionname"` // assigningauthorityversionname
	Distributionsourceversionname sql.NullString `json:"distributionsourceversionname"` // distributionsourceversionname
	Distributionsourceid          string         `json:"distributionsourceid"`          // distributionsourceid
	Assigningauthorityid          string         `json:"assigningauthorityid"`          // assigningauthorityid
	Codesystemcode                string         `json:"codesystemcode"`                // codesystemcode
	Sourceurl                     sql.NullString `json:"sourceurl"`                     // sourceurl
	Hl70396identifier             string         `json:"hl70396identifier"`             // hl70396identifier
	Legacyflag                    bool           `json:"legacyflag"`                    // legacyflag
	Statusdate                    time.Time      `json:"statusdate"`                    // statusdate
	Acquireddate                  sql.NullTime   `json:"acquireddate"`                  // acquireddate
	Effectivedate                 sql.NullTime   `json:"effectivedate"`                 // effectivedate
	Expirydate                    sql.NullTime   `json:"expirydate"`                    // expirydate
	Assigningauthorityreleasedate sql.NullTime   `json:"assigningauthorityreleasedate"` // assigningauthorityreleasedate
	Distributionsourcereleasedate sql.NullTime   `json:"distributionsourcereleasedate"` // distributionsourcereleasedate
	Sdocreatedate                 sql.NullTime   `json:"sdocreatedate"`                 // sdocreatedate
	Lastrevisiondate              time.Time      `json:"lastrevisiondate"`              // lastrevisiondate
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [CodeSystem] exists in the database.
func (view *CodeSystem) Exists() bool {
	return view._exists
}

// Deleted returns true when the [CodeSystem] has been marked for deletion
// from the database.
func (view *CodeSystem) Deleted() bool {
	return view._deleted
}

// Insert inserts the [CodeSystem] to the database.
func (view *CodeSystem) Insert(ctx context.Context, db DB) error {
	switch {
	case view._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case view._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.code_system (` +
		`oid, id, name, definitiontext, status, version, versiondescription, assigningauthorityversionname, distributionsourceversionname, distributionsourceid, assigningauthorityid, codesystemcode, sourceurl, hl70396identifier, legacyflag, statusdate, acquireddate, effectivedate, expirydate, assigningauthorityreleasedate, distributionsourcereleasedate, sdocreatedate, lastrevisiondate` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23` +
		`)`
	// run
	logf(sqlstr, view.Oid, view.ID, view.Name, view.Definitiontext, view.Status, view.Version, view.Versiondescription, view.Assigningauthorityversionname, view.Distributionsourceversionname, view.Distributionsourceid, view.Assigningauthorityid, view.Codesystemcode, view.Sourceurl, view.Hl70396identifier, view.Legacyflag, view.Statusdate, view.Acquireddate, view.Effectivedate, view.Expirydate, view.Assigningauthorityreleasedate, view.Distributionsourcereleasedate, view.Sdocreatedate, view.Lastrevisiondate)
	if _, err := db.ExecContext(ctx, sqlstr, view.Oid, view.ID, view.Name, view.Definitiontext, view.Status, view.Version, view.Versiondescription, view.Assigningauthorityversionname, view.Distributionsourceversionname, view.Distributionsourceid, view.Assigningauthorityid, view.Codesystemcode, view.Sourceurl, view.Hl70396identifier, view.Legacyflag, view.Statusdate, view.Acquireddate, view.Effectivedate, view.Expirydate, view.Assigningauthorityreleasedate, view.Distributionsourcereleasedate, view.Sdocreatedate, view.Lastrevisiondate); err != nil {
		return logerror(err)
	}
	// set exists
	view._exists = true
	return nil
}

// Update updates a [CodeSystem] in the database.
func (view *CodeSystem) Update(ctx context.Context, db DB) error {
	switch {
	case !view._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case view._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.code_system SET ` +
		`id = $1, name = $2, definitiontext = $3, status = $4, version = $5, versiondescription = $6, assigningauthorityversionname = $7, distributionsourceversionname = $8, distributionsourceid = $9, assigningauthorityid = $10, codesystemcode = $11, sourceurl = $12, hl70396identifier = $13, legacyflag = $14, statusdate = $15, acquireddate = $16, effectivedate = $17, expirydate = $18, assigningauthorityreleasedate = $19, distributionsourcereleasedate = $20, sdocreatedate = $21, lastrevisiondate = $22 ` +
		`WHERE oid = $23`
	// run
	logf(sqlstr, view.ID, view.Name, view.Definitiontext, view.Status, view.Version, view.Versiondescription, view.Assigningauthorityversionname, view.Distributionsourceversionname, view.Distributionsourceid, view.Assigningauthorityid, view.Codesystemcode, view.Sourceurl, view.Hl70396identifier, view.Legacyflag, view.Statusdate, view.Acquireddate, view.Effectivedate, view.Expirydate, view.Assigningauthorityreleasedate, view.Distributionsourcereleasedate, view.Sdocreatedate, view.Lastrevisiondate, view.Oid)
	if _, err := db.ExecContext(ctx, sqlstr, view.ID, view.Name, view.Definitiontext, view.Status, view.Version, view.Versiondescription, view.Assigningauthorityversionname, view.Distributionsourceversionname, view.Distributionsourceid, view.Assigningauthorityid, view.Codesystemcode, view.Sourceurl, view.Hl70396identifier, view.Legacyflag, view.Statusdate, view.Acquireddate, view.Effectivedate, view.Expirydate, view.Assigningauthorityreleasedate, view.Distributionsourcereleasedate, view.Sdocreatedate, view.Lastrevisiondate, view.Oid); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [CodeSystem] to the database.
func (view *CodeSystem) Save(ctx context.Context, db DB) error {
	if view.Exists() {
		return view.Update(ctx, db)
	}
	return view.Insert(ctx, db)
}

// Upsert performs an upsert for [CodeSystem].
func (view *CodeSystem) Upsert(ctx context.Context, db DB) error {
	switch {
	case view._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.code_system (` +
		`oid, id, name, definitiontext, status, version, versiondescription, assigningauthorityversionname, distributionsourceversionname, distributionsourceid, assigningauthorityid, codesystemcode, sourceurl, hl70396identifier, legacyflag, statusdate, acquireddate, effectivedate, expirydate, assigningauthorityreleasedate, distributionsourcereleasedate, sdocreatedate, lastrevisiondate` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23` +
		`)` +
		` ON CONFLICT (oid) DO ` +
		`UPDATE SET ` +
		`id = EXCLUDED.id, name = EXCLUDED.name, definitiontext = EXCLUDED.definitiontext, status = EXCLUDED.status, version = EXCLUDED.version, versiondescription = EXCLUDED.versiondescription, assigningauthorityversionname = EXCLUDED.assigningauthorityversionname, distributionsourceversionname = EXCLUDED.distributionsourceversionname, distributionsourceid = EXCLUDED.distributionsourceid, assigningauthorityid = EXCLUDED.assigningauthorityid, codesystemcode = EXCLUDED.codesystemcode, sourceurl = EXCLUDED.sourceurl, hl70396identifier = EXCLUDED.hl70396identifier, legacyflag = EXCLUDED.legacyflag, statusdate = EXCLUDED.statusdate, acquireddate = EXCLUDED.acquireddate, effectivedate = EXCLUDED.effectivedate, expirydate = EXCLUDED.expirydate, assigningauthorityreleasedate = EXCLUDED.assigningauthorityreleasedate, distributionsourcereleasedate = EXCLUDED.distributionsourcereleasedate, sdocreatedate = EXCLUDED.sdocreatedate, lastrevisiondate = EXCLUDED.lastrevisiondate `
	// run
	logf(sqlstr, view.Oid, view.ID, view.Name, view.Definitiontext, view.Status, view.Version, view.Versiondescription, view.Assigningauthorityversionname, view.Distributionsourceversionname, view.Distributionsourceid, view.Assigningauthorityid, view.Codesystemcode, view.Sourceurl, view.Hl70396identifier, view.Legacyflag, view.Statusdate, view.Acquireddate, view.Effectivedate, view.Expirydate, view.Assigningauthorityreleasedate, view.Distributionsourcereleasedate, view.Sdocreatedate, view.Lastrevisiondate)
	if _, err := db.ExecContext(ctx, sqlstr, view.Oid, view.ID, view.Name, view.Definitiontext, view.Status, view.Version, view.Versiondescription, view.Assigningauthorityversionname, view.Distributionsourceversionname, view.Distributionsourceid, view.Assigningauthorityid, view.Codesystemcode, view.Sourceurl, view.Hl70396identifier, view.Legacyflag, view.Statusdate, view.Acquireddate, view.Effectivedate, view.Expirydate, view.Assigningauthorityreleasedate, view.Distributionsourcereleasedate, view.Sdocreatedate, view.Lastrevisiondate); err != nil {
		return logerror(err)
	}
	// set exists
	view._exists = true
	return nil
}

// Delete deletes the [CodeSystem] from the database.
func (view *CodeSystem) Delete(ctx context.Context, db DB) error {
	switch {
	case !view._exists: // doesn't exist
		return nil
	case view._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.code_system ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, view.Oid)
	if _, err := db.ExecContext(ctx, sqlstr, view.Oid); err != nil {
		return logerror(err)
	}
	// set deleted
	view._deleted = true
	return nil
}

// CodeSystemByID retrieves a row from 'public.code_system' as a [CodeSystem].
//
// Generated from index 'code_system_id_key'.
func CodeSystemByID(ctx context.Context, db DB, id string) (*CodeSystem, error) {
	// query
	const sqlstr = `SELECT ` +
		`oid, id, name, definitiontext, status, version, versiondescription, assigningauthorityversionname, distributionsourceversionname, distributionsourceid, assigningauthorityid, codesystemcode, sourceurl, hl70396identifier, legacyflag, statusdate, acquireddate, effectivedate, expirydate, assigningauthorityreleasedate, distributionsourcereleasedate, sdocreatedate, lastrevisiondate ` +
		`FROM public.code_system ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	view := CodeSystem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&view.Oid, &view.ID, &view.Name, &view.Definitiontext, &view.Status, &view.Version, &view.Versiondescription, &view.Assigningauthorityversionname, &view.Distributionsourceversionname, &view.Distributionsourceid, &view.Assigningauthorityid, &view.Codesystemcode, &view.Sourceurl, &view.Hl70396identifier, &view.Legacyflag, &view.Statusdate, &view.Acquireddate, &view.Effectivedate, &view.Expirydate, &view.Assigningauthorityreleasedate, &view.Distributionsourcereleasedate, &view.Sdocreatedate, &view.Lastrevisiondate); err != nil {
		return nil, logerror(err)
	}
	return &view, nil
}

// CodeSystemByOid retrieves a row from 'public.code_system' as a [CodeSystem].
//
// Generated from index 'code_system_pkey'.
func CodeSystemByOid(ctx context.Context, db DB, oid string) (*CodeSystem, error) {
	// query
	const sqlstr = `SELECT ` +
		`oid, id, name, definitiontext, status, version, versiondescription, assigningauthorityversionname, distributionsourceversionname, distributionsourceid, assigningauthorityid, codesystemcode, sourceurl, hl70396identifier, legacyflag, statusdate, acquireddate, effectivedate, expirydate, assigningauthorityreleasedate, distributionsourcereleasedate, sdocreatedate, lastrevisiondate ` +
		`FROM public.code_system ` +
		`WHERE oid = $1`
	// run
	logf(sqlstr, oid)
	view := CodeSystem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, oid).Scan(&view.Oid, &view.ID, &view.Name, &view.Definitiontext, &view.Status, &view.Version, &view.Versiondescription, &view.Assigningauthorityversionname, &view.Distributionsourceversionname, &view.Distributionsourceid, &view.Assigningauthorityid, &view.Codesystemcode, &view.Sourceurl, &view.Hl70396identifier, &view.Legacyflag, &view.Statusdate, &view.Acquireddate, &view.Effectivedate, &view.Expirydate, &view.Assigningauthorityreleasedate, &view.Distributionsourcereleasedate, &view.Sdocreatedate, &view.Lastrevisiondate); err != nil {
		return nil, logerror(err)
	}
	return &view, nil
}

// All retrieves all rows from 'public.code_system'
func GetAllCodeSystems(ctx context.Context, db DB) (*[]CodeSystem, error) {
	const sqlstr = `SELECT * FROM public.code_system`
	logf(sqlstr)
	codeSystems := []CodeSystem{}
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}
	for rows.Next() {
		view := CodeSystem{
			_exists: true,
		}
		err := rows.Scan(&view.Oid, &view.ID, &view.Name, &view.Definitiontext, &view.Status, &view.Version, &view.Versiondescription, &view.Assigningauthorityversionname, &view.Distributionsourceversionname, &view.Distributionsourceid, &view.Assigningauthorityid, &view.Codesystemcode, &view.Sourceurl, &view.Hl70396identifier, &view.Legacyflag, &view.Statusdate, &view.Acquireddate, &view.Effectivedate, &view.Expirydate, &view.Assigningauthorityreleasedate, &view.Distributionsourcereleasedate, &view.Sdocreatedate, &view.Lastrevisiondate)
		if err != nil {
			return nil, logerror(err)
		}
		codeSystems = append(codeSystems, view)
	}
	return &codeSystems, nil
}
