package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// ValueSetVersion represents a row from 'public.value_set_version'.
type ValueSetVersion struct {
	ID                            string         `json:"id"`                            // id
	Valuesetoid                   string         `json:"valuesetoid"`                   // valuesetoid
	Versionnumber                 int            `json:"versionnumber"`                 // versionnumber
	Description                   string         `json:"description"`                   // description
	Status                        string         `json:"status"`                        // status
	Assigningauthoritytext        sql.NullString `json:"assigningauthoritytext"`        // assigningauthoritytext
	Notetext                      sql.NullString `json:"notetext"`                      // notetext
	Statusdate                    time.Time      `json:"statusdate"`                    // statusdate
	Assigningauthorityreleasedate sql.NullTime   `json:"assigningauthorityreleasedate"` // assigningauthorityreleasedate
	Effectivedate                 sql.NullTime   `json:"effectivedate"`                 // effectivedate
	Expirydate                    sql.NullTime   `json:"expirydate"`                    // expirydate
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [ValueSetVersion] exists in the database.
func (vsv *ValueSetVersion) Exists() bool {
	return vsv._exists
}

// Deleted returns true when the [ValueSetVersion] has been marked for deletion
// from the database.
func (vsv *ValueSetVersion) Deleted() bool {
	return vsv._deleted
}

// Insert inserts the [ValueSetVersion] to the database.
func (vsv *ValueSetVersion) Insert(ctx context.Context, db DB) error {
	switch {
	case vsv._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case vsv._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.value_set_version (` +
		`id, valuesetoid, versionnumber, description, status, assigningauthoritytext, notetext, statusdate, assigningauthorityreleasedate, effectivedate, expirydate` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`)`
	// run
	logf(sqlstr, vsv.ID, vsv.Valuesetoid, vsv.Versionnumber, vsv.Description, vsv.Status, vsv.Assigningauthoritytext, vsv.Notetext, vsv.Statusdate, vsv.Assigningauthorityreleasedate, vsv.Effectivedate, vsv.Expirydate)
	if _, err := db.ExecContext(ctx, sqlstr, vsv.ID, vsv.Valuesetoid, vsv.Versionnumber, vsv.Description, vsv.Status, vsv.Assigningauthoritytext, vsv.Notetext, vsv.Statusdate, vsv.Assigningauthorityreleasedate, vsv.Effectivedate, vsv.Expirydate); err != nil {
		return logerror(err)
	}
	// set exists
	vsv._exists = true
	return nil
}

// Update updates a [ValueSetVersion] in the database.
func (vsv *ValueSetVersion) Update(ctx context.Context, db DB) error {
	switch {
	case !vsv._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case vsv._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.value_set_version SET ` +
		`valuesetoid = $1, versionnumber = $2, description = $3, status = $4, assigningauthoritytext = $5, notetext = $6, statusdate = $7, assigningauthorityreleasedate = $8, effectivedate = $9, expirydate = $10 ` +
		`WHERE id = $11`
	// run
	logf(sqlstr, vsv.Valuesetoid, vsv.Versionnumber, vsv.Description, vsv.Status, vsv.Assigningauthoritytext, vsv.Notetext, vsv.Statusdate, vsv.Assigningauthorityreleasedate, vsv.Effectivedate, vsv.Expirydate, vsv.ID)
	if _, err := db.ExecContext(ctx, sqlstr, vsv.Valuesetoid, vsv.Versionnumber, vsv.Description, vsv.Status, vsv.Assigningauthoritytext, vsv.Notetext, vsv.Statusdate, vsv.Assigningauthorityreleasedate, vsv.Effectivedate, vsv.Expirydate, vsv.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [ValueSetVersion] to the database.
func (vsv *ValueSetVersion) Save(ctx context.Context, db DB) error {
	if vsv.Exists() {
		return vsv.Update(ctx, db)
	}
	return vsv.Insert(ctx, db)
}

// Upsert performs an upsert for [ValueSetVersion].
func (vsv *ValueSetVersion) Upsert(ctx context.Context, db DB) error {
	switch {
	case vsv._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.value_set_version (` +
		`id, valuesetoid, versionnumber, description, status, assigningauthoritytext, notetext, statusdate, assigningauthorityreleasedate, effectivedate, expirydate` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`valuesetoid = EXCLUDED.valuesetoid, versionnumber = EXCLUDED.versionnumber, description = EXCLUDED.description, status = EXCLUDED.status, assigningauthoritytext = EXCLUDED.assigningauthoritytext, notetext = EXCLUDED.notetext, statusdate = EXCLUDED.statusdate, assigningauthorityreleasedate = EXCLUDED.assigningauthorityreleasedate, effectivedate = EXCLUDED.effectivedate, expirydate = EXCLUDED.expirydate `
	// run
	logf(sqlstr, vsv.ID, vsv.Valuesetoid, vsv.Versionnumber, vsv.Description, vsv.Status, vsv.Assigningauthoritytext, vsv.Notetext, vsv.Statusdate, vsv.Assigningauthorityreleasedate, vsv.Effectivedate, vsv.Expirydate)
	if _, err := db.ExecContext(ctx, sqlstr, vsv.ID, vsv.Valuesetoid, vsv.Versionnumber, vsv.Description, vsv.Status, vsv.Assigningauthoritytext, vsv.Notetext, vsv.Statusdate, vsv.Assigningauthorityreleasedate, vsv.Effectivedate, vsv.Expirydate); err != nil {
		return logerror(err)
	}
	// set exists
	vsv._exists = true
	return nil
}

// Delete deletes the [ValueSetVersion] from the database.
func (vsv *ValueSetVersion) Delete(ctx context.Context, db DB) error {
	switch {
	case !vsv._exists: // doesn't exist
		return nil
	case vsv._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.value_set_version ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, vsv.ID)
	if _, err := db.ExecContext(ctx, sqlstr, vsv.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	vsv._deleted = true
	return nil
}

// ValueSetVersionByID retrieves a row from 'public.value_set_version' as a [ValueSetVersion].
//
// Generated from index 'value_set_version_pkey'.
func ValueSetVersionByID(ctx context.Context, db DB, id string) (*ValueSetVersion, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, valuesetoid, versionnumber, description, status, assigningauthoritytext, notetext, statusdate, assigningauthorityreleasedate, effectivedate, expirydate ` +
		`FROM public.value_set_version ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	vsv := ValueSetVersion{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&vsv.ID, &vsv.Valuesetoid, &vsv.Versionnumber, &vsv.Description, &vsv.Status, &vsv.Assigningauthoritytext, &vsv.Notetext, &vsv.Statusdate, &vsv.Assigningauthorityreleasedate, &vsv.Effectivedate, &vsv.Expirydate); err != nil {
		return nil, logerror(err)
	}
	return &vsv, nil
}

// ValueSetVersionByValuesetoid retrieves a row from 'public.value_set_version' as a [ValueSetVersion].
//
// Generated from index 'value_set_version_valuesetoid_idx'.
func ValueSetVersionByValuesetoid(ctx context.Context, db DB, valuesetoid string) ([]*ValueSetVersion, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, valuesetoid, versionnumber, description, status, assigningauthoritytext, notetext, statusdate, assigningauthorityreleasedate, effectivedate, expirydate ` +
		`FROM public.value_set_version ` +
		`WHERE valuesetoid = $1`
	// run
	logf(sqlstr, valuesetoid)
	rows, err := db.QueryContext(ctx, sqlstr, valuesetoid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*ValueSetVersion
	for rows.Next() {
		vsv := ValueSetVersion{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&vsv.ID, &vsv.Valuesetoid, &vsv.Versionnumber, &vsv.Description, &vsv.Status, &vsv.Assigningauthoritytext, &vsv.Notetext, &vsv.Statusdate, &vsv.Assigningauthorityreleasedate, &vsv.Effectivedate, &vsv.Expirydate); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &vsv)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// ValueSet returns the ValueSet associated with the [ValueSetVersion]'s (Valuesetoid).
//
// Generated from foreign key 'value_set_version_valuesetoid_fkey'.
func (vsv *ValueSetVersion) ValueSet(ctx context.Context, db DB) (*ValueSet, error) {
	return ValueSetByOid(ctx, db, vsv.Valuesetoid)
}
